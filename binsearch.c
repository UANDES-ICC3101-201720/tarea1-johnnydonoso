#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <getopt.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <stdbool.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include "types.h"
#include "const.h"
#include "util.h"

int largo;
int key;


bool serial_binsearch(unsigned int buffer[], int first, int largo, int key) {
	bool encontrado= false;	//serial binsearch
	int first1= first;
	int last= largo-1;
	while (first1<=last && encontrado==false){
		int middle=(first1+last)/2;
		if (buffer[middle]< key)
			first1 = middle+1;
		else if (buffer[middle]==key){
			encontrado=true;
			break;}
		else{last = middle -1;}}
	return encontrado;
}

void parallel_binsearch(unsigned int buffer[],int first, int largo, int key) {
	bool encontrado= false;
	int last = largo-1;
	while(first<=last && !encontrado){
		int middle=(first+last)/2;
		if(key<middle){
			last = middle+1;}
		else if(key>middle){
			first= middle-1;}
		else{encontrado= true;} }
	return encontrado;
}

int main(int argc, char** argv) {

    printf("[binsearch] Starting up...\n");

    /* Get the number of CPU cores available */
    printf("[binsearch] Number of cores available: '%ld'\n",sysconf(_SC_NPROCESSORS_ONLN));
	
	char *t;//dato t en char
	int flag2=0;//dato t;
	int flag4=0;//dato e
	int flag6=0;//dato p
	int c;
	opterr=0;
	
	while((c=getopt(argc,argv,"T:E:P:")) !=-1 )
	{
		switch(c){
			case 'T':
				t= optarg;
				flag2= atoi(optarg);
				break;
			case 'E':
				flag4= atoi(optarg);
				break;
			case 'P':
				flag6=atoi(optarg);
				break;
			case '?':
				if(optopt=='T'){
					fprintf(stderr, "OPCION -%c requiere un argumento.\n",optopt);}
				if(optopt=='E'){
					fprintf(stderr, "OPCION -%c requiere un argumento.\n",optopt);}
				if(optopt=='P'){
					fprintf(stderr, "OPCION -%c requiere un argumento.\n",optopt);}
				else if(isprint(optopt))
					fprintf(stderr, "Opcion desconocida");
				else
					fprintf(stderr,"Caracter desconocido");
				return 1;
			default:
				abort();
			 }
	}
	 /* TODO: start datagen here as a child process. */
	
	
	int pid;
	pid= fork();
	if(pid==0)
	{
		if(execv("./datagen",argv)<0){
			fprintf(stderr, "Fallo en execv :(");
			exit(0);}
	}
	if (pid==-1)
	{
		fprintf(stderr,"No se creo el proceso hijo\n");
		exit(0);
	}

    /* TODO: connect to datagen and ask for the necessary data in each experiment round.
     * Create a Unix domain socket with DSOCKET_PATH (see const.h).
     * Talk to datagen using the messages specified in the assignment description document.
     * Read the values generated by datagen from the socket and use them to run your
     * experiments
     * */
	//creando socket
	struct sockaddr_un addr;
  	int fd;
	int largo = pow(10,flag2);
	
	if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    		perror("socket error");
    		exit(-1);}
	
	//conectando sockets
	memset(&addr, 0, sizeof(addr));
  	addr.sun_family = AF_UNIX;
	
	strncpy(addr.sun_path, DSOCKET_PATH, sizeof(addr.sun_path));

	if(connect(fd, (struct sockaddr*)&addr, sizeof(addr))==-1){
		perror("error de conecciÃ³n");
		exit(-1);}
	
	//escribiendo comienzo en el socket
	char start[]="BEGIN S";
	strcat(start, t);
	if(write(fd, start,sizeof(start))==-1){
		perror("error dando instrucciones de inicio");
		exit(-1);}
	
	//generando datagen	
	long unsigned int leidos=0;
	size_t valores = largo;
	size_t rb=0;
	UINT *readbuf = malloc(sizeof(UINT)*valores);
	while(rb<valores)
	{
		rb= read(fd, readbuf+leidos,sizeof(UINT)*1000);
		leidos= (leidos + rb)/4;
	}
	
	if(write(fd, DATAGEN_END_CMD,sizeof(DATAGEN_END_CMD))==-1)
	{printf("error terminando datagen");}
	
	 /* TODO: implement code for your experiments using data provided by datagen and your
     * serial and parallel versions of binsearch.
     * */
	
	struct timespec start1, finish;
	double tiempo1 = 0;
	double tiempo_p = 0;
	for (int i = 0; i < flag4; i++)
	{
		//tomando tiempo del serial binsearch
	       	clock_gettime(CLOCK_MONOTONIC, &start1);
	        serial_binsearch(readbuf, 0, numvalues, flag6);
	        clock_gettime(CLOCK_MONOTONIC, &finish);
	        tiempo1 = (finish.tv_sec - start1.tv_sec);
	        tiempo1 += (finish.tv_nsec - start1.tv_nsec) / 1000000000.0;
		//tomando tiempo del binsearch paralelo.
	        clock_gettime(CLOCK_MONOTONIC, &start1);
	        parallel_binsearch(readbuf, 0, numvalues, flag6);
	        clock_gettime(CLOCK_MONOTONIC, &finish);
	        tiempo_p = (finish.tv_sec - start1.tv_sec);
	        tiempo_p += (finish.tv_nsec - start1.tv_nsec) / 1000000000.0;
	        printf("%d, %d, %lf, %lf\n", flag2, flag4, tiempo1, tiempo_p); 
	    }
	    free(readbuf);
	    return 0;
}
